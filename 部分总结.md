# 变量提升
1. `var`关键字
```javascript
console.log(global); // undefined
var global = 'global';
console.log(global); // global
var a = 'bbb';
function fn () {
　　console.log(a); // undefined
　　var a = 'aaa';
　　console.log(a); // aaa
}
fn();
```

2. 函数声明与函数表达式声明
```javascript
//函数声明会将整个函数体提前
function foo(){
    console.log('这是函数声明');
}
//函数表达式声明函数不会将整个函数体提前，但是会将变量提升（与普通变量提升无异）
var foo = function(){
    console.log('这是函数表达式声明函数');
}
```

3. `let`关键字
- 有块作用域
- 不存在变量提升，如果未声明先使用，会报错
- 重复使用`let`关键字对同一个变量进行声明，会报错

[都是JavaScript的知识盲点](http://www.toutiao.com/a6415315232172425473/?tt_from=weixin&utm_campaign=client_share&app=news_article&utm_source=weixin&iid=9725955303&utm_medium=toutiao_android&wxshare_count=1)

# IE89 浏览器兼容性问题
- IE9下table的td标签如果之间存在空格，会引起表格样式的错乱（特别是在使用模板生成表格的时候特别需要注意）
- IE8下js代码中如果使用了保留关键字需要使用引号进行包裹（不推荐在js中使用保留的关键字，但是在一些组件中可能会存在这种问题，在使用的时候碰到就比较坑爹了，在ie8下定位又特别困难。这个问题在ie9+及其他标准浏览器中没有这个问题）
- IE8下form表单中的`button`标签没有设置`type`属性情况下，浏览器会默认解析为`submit`行为，所以会引起一些问题，在开发中涉及到`button`的`type`属性值，都要设置好。
- IE89下使用jQuery进行跨域操作时会存在兼容性问题，这个问题是因为ie89跨域是通过`XDomainRequest`对象进行的，但是jQuery没有对此做兼容性处理导致的。其他浏览器（IE10+/chrome等）都是支持`XMLHttpRequest`对象的

# 事件委托 
## 原生js事件机制
主要事件处理函数：`addEventListener/attachEvent`、`removeEventListener`、`dispatchEvent`。

`attachEvent`在IE10+浏览器都已经不被支持，暂不研究`attachEvent`的事件绑定

`addEventListener(type, listener[, useCapture])`第一个参数事件类型，第二个参数是回调函数，第三个参数为`true`则为添加捕获阶段的事件处理函数，否则为添加冒泡阶段的事件处理函数。
```html
<ul id="test">
    <li>
        <p>11111111111</p>
    </li>
    <li>
        <div>
            22222222
        </div>
    </li>
    <li>
        <span>3333333333</span>
    </li>
    <li>4444444</li>
</ul>
```

```javascript
var el = document.querySelector('#test');
el.addEventListener('click',function(e){
    var e = e || window.event;
    var target = e.target || e.srcElement;
    //嵌套多层时，进行事件委托，需要进行递归调用
    while(target !== el){
        if(target.nodeName.toLocaleLowerCase() === 'li'){
            console.log('click nodeName is:'+ target);
            break;
        }
        target = target.parentNode;
    }
    console.log('clicked');
},true);
```
## backbone事件机制
[backbone的源码line:1401](https://github.com/jashkenas/backbone/blob/master/backbone.js#L1401)，使用的是jQuery的事件委托，直接在当前view上面进行委托（以前都没有注意到backbone还要依赖jquery）其实`Backbone.View`是需要依赖`jQuery`的....
## jQuery事件机制
jQuery的事件机制和事件委托详情看参考文档，自己也还没有太理解透彻

《jQuery的事件委托处理》
《jQuery-1.9.1源码分析系列（十） 事件系统——事件绑定》

参考文档：

[DOM 事件与 jQuery 源码：捕获与冒泡](http://harttle.com/2015/07/31/javascript-event.html)

[JavaScript 事件委托详解](https://juejin.im/post/58fd95bcac502e0063b197db)

[事件委托详解](http://www.cnblogs.com/liugang-vip/p/5616484.html)

[jQuery的事件委托处理](http://www.cnblogs.com/chuaWeb/p/jQuery-1-9-1-addEvents-3.html)

[jQuery-1.9.1源码分析系列（十） 事件系统——事件绑定](http://www.cnblogs.com/chuaWeb/p/jQuery-1-9-1-addEvents-2.html)

# require原理
当 Node 遇到 require(X) 时，按下面的顺序处理。
1. 如果 X 是内置模块（比如 require('http'）) 
- 返回该模块。 
- 不再继续执行。

2. 如果 X 以 "./" 或者 "/" 或者 "../" 开头 
- 根据 X 所在的父模块，确定 X 的绝对路径。 
- 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。
    ```javascript
    X
    X.js
    X.json
    X.node
    ```
- 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。
    ```javascript
    X/package.json（main字段）
    X/index.js
    X/index.json
    X/index.node
    ```
3. 如果 X 不带路径 
- 根据 X 所在的父模块，确定 X 可能的安装目录。 
- 依次在每个目录中，将 X 当成文件名或目录名加载。
4. 抛出 "not found"

require模块时实际上是调用的是模块自身的实例`module`的[`_load`](https://github.com/nodejs/node/blob/master/lib/module.js#L432)方法

`_load`方法主要进行了这么些步骤

1. 确定模块的路径（会罗列出所有的可能路径）
2. 判断模块是否已经加载（如果已经加载过，直接从缓存取）
3. 判断是否是内置模块（如果是内置模块，则调用内置模块的require方法）
4. 生成一个模块实例，并将其缓存起来
5. 加载模块
6. 返回模块的`export`属性

参考文档

[require() 源码解读](http://www.ruanyifeng.com/blog/2015/05/require.html)


参考文档

# 闭包
- 什么是闭包
- 闭包应用场景

[破解前端面试（80% 应聘者不及格系列）：从闭包说起](https://juejin.im/post/58f1fa6a44d904006cf25d22)

[JavaScript 闭包](https://segmentfault.com/a/1190000006875662)

# 原型继承
[js中的new()到底做了些什么？？](http://www.cnblogs.com/faith3/p/6209741.html)

# 客户端发送请求过程

1. 在客户端输入URL地址
2. 对URL进行DNS解析（如果有本地缓存，则直接使用本地缓存进行解析）
3. 访问DNS服务器，进行URL解析
4. 获取ip地址，建立TCP/IP连接
5. 向服务器发起HTTP请求
6. 服务器解析请求，然后返回数据
7. 客户端解析返回的数据，进行显示

# http协议请求头的含义

请求行： 请求方式 空格 请求地址 空格 协议版本 回车换行

请求头部：字段名：值 回车换行

​		   字段名：值 回车换行

请求数据：请求数据

```javascript
GET / HTTP/1.1
Host: www.baidu.com
Connection: keep-alive
Upgrade-Insecure-Requests: 1
Content-length: 20
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
```

# 单页应用的优缺点

优点：

1. 用户体验好
2. 减轻服务器的压力，只需要进行数据输出
3. 能够进行前后端分离

缺点：

1. SEO问题不友好
2. 对浏览器的浏览历史不友好
3. 对浏览器书签支持不友好

# 跨域处理（json原理等）

服务器端：

1. CORS
2. 反向代理

客户端：

1. JSONP
2. postMeassage
3. window.name
4. window.domain

# backbone理解

# 最近遇到的问题

表格的自适应，table-cell