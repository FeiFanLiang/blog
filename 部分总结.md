# 变量提升
1. `var`关键字
```javascript
console.log(global); // undefined
var global = 'global';
console.log(global); // global
var a = 'bbb';
function fn () {
　　console.log(a); // undefined
　　var a = 'aaa';
　　console.log(a); // aaa
}
fn();
 ```

2. 函数声明与函数表达式声明
```javascript
//函数声明会将整个函数体提前
function foo(){
    console.log('这是函数声明');
}
//函数表达式声明函数不会将整个函数体提前，但是会将变量提升（与普通变量提升无异）
var foo = function(){
    console.log('这是函数表达式声明函数');
}
```

3. `let`关键字
- 有块作用域
- 不存在变量提升，如果未声明先使用，会报错
- 重复使用`let`关键字对同一个变量进行声明，会报错

# IE89 浏览器兼容性问题
- IE9下table的td标签如果之间存在空格，会引起表格样式的错乱（特别是在使用模板生成表格的时候特别需要注意）
- IE8下js代码中如果使用了保留关键字需要使用引号进行包裹（不推荐在js中使用保留的关键字，但是在一些组件中可能会存在这种问题，在使用的时候碰到就比较坑爹了，在ie8下定位又特别困难。这个问题在ie9+及其他标准浏览器中没有这个问题）
- IE8下form表单中的`button`标签没有设置`type`属性情况下，浏览器会默认解析为`submit`行为，所以会引起一些问题，在开发中涉及到`button`的`type`属性值，都要设置好。
- IE89下使用jQuery进行跨域操作时会存在兼容性问题，这个问题是因为ie89跨域是通过`XDomainRequest`对象进行的，但是jQuery没有对此做兼容性处理导致的。其他浏览器（IE10+/chrome等）都是支持`XMLHttpRequest`对象的

# 事件委托 
## 原生js事件机制
主要事件处理函数：`addEventListener/attachEvent`、`removeEventListener`、`dispatchEvent`。

`attachEvent`在IE10+浏览器都已经不被支持，暂不研究`attachEvent`的事件绑定

`addEventListener(type, listener[, useCapture])`第一个参数事件类型，第二个参数是回调函数，第三个参数为`true`则为添加捕获阶段的事件处理函数，否则为添加冒泡阶段的事件处理函数。
```html
<ul id="test">
    <li>
        <p>11111111111</p>
    </li>
    <li>
        <div>
            22222222
        </div>
    </li>
    <li>
        <span>3333333333</span>
    </li>
    <li>4444444</li>
</ul>
```

```javascript
var el = document.querySelector('#test');
el.addEventListener('click',function(e){
    var e = e || window.event;
    var target = e.target || e.srcElement;
    //嵌套多层时，进行事件委托，需要进行递归调用
    while(target !== el){
        if(target.nodeName.toLocaleLowerCase() === 'li'){
            console.log('click nodeName is:'+ target);
            break;
        }
        target = target.parentNode;
    }
    
    console.log('clicked');
},true);
```
## backbone事件机制
[backbone的源码line:1401](https://github.com/jashkenas/backbone/blob/master/backbone.js#L1401)，使用的是jQuery的事件委托，直接在当前view上面进行委托（以前都没有注意到backbone还要依赖jquery）其实`Backbone.View`是需要依赖`jQuery`的....
## jQuery事件机制
jQuery的事件机制和事件委托详情看参考文档，自己也还没有太理解透彻

《jQuery的事件委托处理》
《jQuery-1.9.1源码分析系列（十） 事件系统——事件绑定》

参考文档：

[DOM 事件与 jQuery 源码：捕获与冒泡](http://harttle.com/2015/07/31/javascript-event.html)

[JavaScript 事件委托详解](https://juejin.im/post/58fd95bcac502e0063b197db)

[事件委托详解](http://www.cnblogs.com/liugang-vip/p/5616484.html)

[jQuery的事件委托处理](http://www.cnblogs.com/chuaWeb/p/jQuery-1-9-1-addEvents-3.html)

[jQuery-1.9.1源码分析系列（十） 事件系统——事件绑定](http://www.cnblogs.com/chuaWeb/p/jQuery-1-9-1-addEvents-2.html)

# require原理
当 Node 遇到 require(X) 时，按下面的顺序处理。
1. 如果 X 是内置模块（比如 require('http'）) 
- 返回该模块。 
- 不再继续执行。

2. 如果 X 以 "./" 或者 "/" 或者 "../" 开头 
- 根据 X 所在的父模块，确定 X 的绝对路径。 
- 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。
    ```javascript
    X
    X.js
    X.json
    X.node
    ```
- 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。
    ```javascript
    X/package.json（main字段）
    X/index.js
    X/index.json
    X/index.node
    ```
3. 如果 X 不带路径 
- 根据 X 所在的父模块，确定 X 可能的安装目录。 
- 依次在每个目录中，将 X 当成文件名或目录名加载。
4. 抛出 "not found"

require模块时实际上是调用的是模块自身的实例`module`的[`_load`](https://github.com/nodejs/node/blob/master/lib/module.js#L432)方法

`_load`方法主要进行了这么些步骤

1. 确定模块的路径（会罗列出所有的可能路径）
2. 判断模块是否已经加载（如果已经加载过，直接从缓存取）
3. 判断是否是内置模块（如果是内置模块，则调用内置模块的require方法）
4. 生成一个模块实例，并将其缓存起来
5. 加载模块
6. 返回模块的`export`属性

参考文章

[require() 源码解读](http://www.ruanyifeng.com/blog/2015/05/require.html)

